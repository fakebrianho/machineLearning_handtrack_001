{"version":3,"file":"bundle.59958b342168096b36a4.js","mappings":"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","sources":["webpack:///./src/shaders/vertexShader.glsl","webpack:///./src/script.js","webpack:///./src/shaders/fragmentShader.glsl"],"sourcesContent":["export default \"uniform float uTime;\\nuniform float uFreq;\\nvarying vec3 newPos;\\nvarying vec2 vUv;\\nvarying vec3 vNormal;\\nvarying float pulse;\\n\\n// varying vec2 vUv;\\n//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x)\\n{\\n  return mod289(((x*34.0)+10.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec3 fade(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\n// Classic Perlin noise\\nfloat cnoise(vec3 P)\\n{\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\nvarying float noise;\\n\\nfloat turbulence( vec3 p ) {\\n\\n  float w = 100.0;\\n  float t = -.5;\\n\\n  for (float f = 1.0 ; f <= 10.0 ; f++ ){\\n    float power = pow( 2.0, f );\\n    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\\n  }\\n\\n  return t;\\n\\n}\\n\\nvoid main() {\\n\\n  vUv = uv;\\n\\n   noise = 10.0 *  -.10 * turbulence( .5 * normal + uTime );\\n  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * uTime ), vec3( 100.0 ) );\\n  float displacement = - noise + b;\\n  // move the position along the normal and transform it\\n  vec3 newPosition = position + normal * displacement;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\\n\\n\\n}\\n\";","const video = document.getElementById('myvideo')\nconst handimg = document.getElementById('handimage')\nconst canvas = document.getElementById('canvas')\nconst context = canvas.getContext('2d')\nlet trackButton = document.getElementById('trackbutton')\nlet nextImageButton = document.getElementById('nextimagebutton')\nlet updateNote = document.getElementById('updatenote')\nlet preloader = document.getElementById('preload')\nlet track = []\nlet isVideo = false\nlet model = null\nlet mappedVal\nlet mappedValY\nimport vertex from './shaders/vertexShader.glsl'\nimport fragment from './shaders/fragmentShader.glsl'\nconst pointer = new THREE.Vector2()\n\nconst modelParams = {\n\tflipHorizontal: true, // flip e.g for video\n\tmaxNumBoxes: 20, // maximum number of boxes to detect\n\tiouThreshold: 0.5, // ioU threshold for non-max suppression\n\tscoreThreshold: 0.6, // confidence threshold for predictions.\n}\n\nfunction startVideo() {\n\thandTrack.startVideo(video).then(function (status) {\n\t\tvideo.style.display = 'none'\n\t\t// console.log('video started', status)\n\t\tif (status) {\n\t\t\t// updateNote.innerText = 'Video started. Now tracking'\n\t\t\tisVideo = true\n\t\t\trunDetection()\n\t\t} else {\n\t\t\t// updateNote.innerText = 'Please enable video'\n\t\t}\n\t})\n}\n\nfunction toggleVideo() {\n\tgsap.to(preloader, { opacity: 0, delay: 0.5, duration: 1.5 })\n\t// preloader.style.opacity = 0\n\tif (!isVideo) {\n\t\t// updateNote.innerText = 'Starting video'\n\t\tstartVideo()\n\t} else {\n\t\t// updateNote.innerText = 'Stopping video'\n\t\thandTrack.stopVideo(video)\n\t\tisVideo = false\n\t\t// updateNote.innerText = 'Video stopped'\n\t}\n}\n\ntrackButton.addEventListener('click', function () {\n\ttoggleVideo()\n})\n\nfunction runDetection() {\n\tmodel.detect(video).then((predictions) => {\n\t\t// console.log('Predictions: ', predictions)\n\t\ttrack = predictions.slice(0)\n\t\t// model.renderPredictions(predictions, canvas, context, video)\n\t\t//code taken from the pong boilerplate in the handtrack.js demo, here I'm normalizing\n\t\t// console.log(predictions)\n\t\tpredictions.forEach((prediction) => {\n\t\t\tif (prediction.label == 'face') {\n\t\t\t\tlet midval = prediction.bbox[0] + prediction.bbox[2] / 2\n\t\t\t\tlet midvalY = prediction.bbox[1] + prediction.bbox[2] / 2\n\n\t\t\t\tlet midval2 = midval / video.width\n\t\t\t\tlet midvalY2 = midvalY / video.height\n\t\t\t\tmappedVal = mapRange(midval2, 0, 1, -1, 1)\n\t\t\t\tmappedValY = mapRange(midvalY2, 0, 1, -1, 1)\n\t\t\t}\n\t\t})\n\t\t// if (predictions[0]) {\n\t\t// \tlet midval = predictions[0].bbox[0] + predictions[0].bbox[2] / 2\n\t\t// \tlet midvalY = predictions[0].bbox[1] + predictions[0].bbox[2] / 2\n\t\t// \tlet midval2 = midval / video.width\n\t\t// \tlet midvalY2 = midvalY / video.height\n\t\t// \tmappedVal = mapRange(midval2, 0, 1, -1, 1)\n\t\t// \tmappedValY = mapRange(midvalY2, 0, 1, -1, 1)\n\t\t// }\n\t\tmodel.renderPredictions(predictions, canvas, context, video)\n\t\tif (isVideo) {\n\t\t\trequestAnimationFrame(runDetection)\n\t\t}\n\t})\n}\n\n// Load the model.\nhandTrack.load(modelParams).then((lmodel) => {\n\tmodel = lmodel\n\tconsole.log(model)\n\t// updateNote.innerText = 'Loaded Model!'\n\ttrackButton.disabled = false\n})\n\n/*------------------------------\nGlobal Setup\n------------------------------*/\nconst canvas3 = document.querySelector('.threeCanvas')\nconst scene = new THREE.Scene()\nconst renderer = new THREE.WebGLRenderer({\n\tcanvas: canvas3,\n})\nvar img = document.getElementById('texture')\nlet texture\nlet dummyimg = document.createElement('img')\ndummyimg.onload = function () {\n\t// document.body.classList.remove('loading')\n\timg.style.opacity = 0\n\t// console.log('asdf')\n\ttexture = new THREE.Texture(this)\n\ttexture.needsUpdate = true\n\n\t// init()\n\tconsole.log(texture)\n\t// animate()\n\tconst geometry1 = new THREE.IcosahedronGeometry(10, 4)\n\n\tconst material1 = new THREE.MeshBasicMaterial({\n\t\tmap: texture,\n\t})\n\tconsole.log(texture)\n\tconst newMesh = new THREE.Mesh(geometry1, material1)\n\tscene.add(newMesh)\n}\ndummyimg.src = img.src\n\nconst loader = new THREE.TextureLoader()\n\nconst light = new THREE.AmbientLight(0x404040) // soft white light\nscene.add(light)\nconst geometry = new THREE.IcosahedronGeometry(10, 4)\n// const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })\nconst material = new THREE.ShaderMaterial({\n\tuniforms: {\n\t\ttExplosion: {\n\t\t\ttype: 't',\n\t\t\tvalue: texture,\n\t\t},\n\t\tuTime: { value: 0 },\n\t\tuFreq: { value: 0 },\n\t},\n\t// uniforms: {\n\t// \ttime: {\n\t// \t\t// float initialized to 0\n\t// \t\ttype: 'f',\n\t// \t\tvalue: 0.0,\n\t// \t},\n\t// },\n\tvertexShader: vertex,\n\tfragmentShader: fragment,\n})\n// const material = new THREE.ShaderMaterial({\n// \tvertexShader: document.getElementById('vertexShader').textContent,\n// \tfragmentShader: document.getElementById('fragmentShader').textContent,\n// })\n// console.log(document.getElementById('vertexShader').textContent)\n// mesh = new THREE.Mesh(\n//     material\n//   );\nconst mesh = new THREE.Mesh(geometry, material)\nscene.add(mesh)\n\n/*------------------------------\nDimensions\n------------------------------*/\nconst sizes = {\n\twidth: window.innerWidth,\n\theight: window.innerHeight,\n}\n\nconst camera = new THREE.PerspectiveCamera(\n\t75,\n\tsizes.width / sizes.height,\n\t0.1,\n\t1000\n)\ncamera.position.z = 30\nscene.add(camera)\n\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n/*------------------------------\nResize\n------------------------------*/\nwindow.addEventListener('resize', () => {\n\t/*------------------------------\n  Update Sizes\n  ------------------------------*/\n\tsizes.width = window.innerWidth\n\tsizes.height = window.innerHeight\n\t/*------------------------------\n  Update Camera\n  ------------------------------*/\n\tcamera.aspect = sizes.width / sizes.height\n\tcamera.updateProjectionMatrix()\n\t/*------------------------------\n  Update Renderer\n  ------------------------------*/\n\trenderer.setSize(sizes.width, sizes.height)\n\trenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n})\n\n/*------------------------------\nFullscreen Function\n------------------------------*/\nwindow.addEventListener('dblclick', () => {\n\tif (!document.fullscreenElement) {\n\t\tcanvas.requestFullscreen()\n\t} else {\n\t\tdocument.exitFullscreen()\n\t}\n})\n/*------------------------------\nmover\n------------------------------*/\n\nclass Mover {\n\tconstructor(x, y, z, m, radius, widthSeg, heightSeg) {\n\t\tthis.geometry = new THREE.SphereBufferGeometry(\n\t\t\tradius,\n\t\t\twidthSeg,\n\t\t\theightSeg\n\t\t)\n\t\tthis.testGeo = new THREE.BoxGeometry(1, 1, 1)\n\t\tthis.material = new THREE.MeshBasicMaterial({ color: '#ff00ff' })\n\t\tthis.position = new THREE.Vector3(x, y, z)\n\t\tthis.vel = new THREE.Vector3(\n\t\t\tMath.random() * 0.11,\n\t\t\tMath.random() * 0.11,\n\t\t\t0\n\t\t)\n\t\tthis.acc = new THREE.Vector3(0, 0, 0)\n\t\tthis.mass = m\n\t\tthis.mesh = new THREE.Mesh(this.testGeo, this.material)\n\t}\n\n\tapplyForce(force) {\n\t\tlet f = force\n\t\tthis.acc.add(f)\n\t}\n\n\tupdate() {\n\t\tthis.vel.add(this.acc)\n\t\tthis.vel.clampScalar(-0.09, 0.09) // clamp speed\n\t\t// console.log(this.vel)\n\t\tthis.mesh.position.add(this.vel)\n\t\tthis.acc.set(0, 0, 0)\n\t}\n}\nlet test = new Mover(0, -0.5, 0, 15, 32, 16)\nscene.add(test.mesh)\n/*------------------------------\nAttraction Function\n------------------------------*/\nconst attract = (mover, attractor, amass, mmass) => {\n\tlet a = new THREE.Vector3(attractor.position.x, attractor.position.y, 0.5)\n\tlet b = new THREE.Vector3(mover.mesh.position.x, mover.mesh.position.y, 0.5)\n\tlet force = a.sub(b)\n\tforce.setLength(0.17)\n\t// console.log(force)\n\tlet strength\n\t/*------------------------------\n    Block\n    ------------------------------*/\n\t// console.log(a)\n\t// let distanceSquared =\n\t// \tforce.x * force.x + force.y * force.y + force.z * force.z\n\t// let g = 1\n\t// if (distanceSquared > 0) {\n\t// \tstrength = (amass * mmass) / distanceSquared\n\t// } else {\n\t// \tstrength = 0\n\t// }\n\t/*------------------------------\n    Block\n    ------------------------------*/\n\n\t// force = force.normalize()\n\t// force = force.normalize().multiplyScalar(strength)\n\t// dir = dir.sub(mover.pos)\n\t// console.log(force)\n\t// console.log(distanceSquared)\n\t// console.log(strength)\n\tmover.applyForce(force)\n\t// .sub(attractor.pos, mover.pos)\n}\n\nwindow.addEventListener('pointermove', onPointerMove)\nfunction mapRange(value, a, b, c, d) {\n\t// first map value from (a..b) to (0..1)\n\tvalue = (value - a) / (b - a)\n\t// then map it from (0..1) to (c..d) and return it\n\treturn c + value * (d - c)\n}\nfunction onPointerMove(event) {\n\t// calculate pointer position in normalized device coordinates\n\t// (-1 to +1) for both components\n\t// pointer.x = (event.clientX / window.innerWidth) * 2 - 1\n\t// pointer.y = -(event.clientY / window.innerHeight) * 2 + 1\n\t// var vector = new THREE.Vector3(pointer.x, pointer.y, 0.5)\n\t// vector.unproject(camera)\n\t// var dir = vector.sub(camera.position).normalize()\n\t// var distance = -camera.position.z / dir.z\n\t// var pos = camera.position.clone().add(dir.multiplyScalar(distance))\n\t// mesh.position.copy(pos)\n}\n\n//Map function from p5\n\nconst clock = new THREE.Clock()\nconst animate = () => {\n\t/*------------------------------\n  Smooth Animation\n  ------------------------------*/\n\tconst elapsedTime = clock.getElapsedTime()\n\n\t/*------------------------------\n  Update Meshes\n  ------------------------------*/\n\n\ttrack.forEach((tracked) => {\n\t\tif (tracked.label == 'closed') {\n\t\t\tmesh.rotation.x = elapsedTime\n\t\t\tmesh.rotation.y = elapsedTime\n\t\t\tattract(test, mesh, 1, 1)\n\t\t}\n\t})\n\t// console.log(mappedValY)\n\tif (mappedValY) {\n\t\tvar vector = new THREE.Vector3(mappedVal, -mappedValY, 0.5)\n\t\tvector.unproject(camera)\n\t\tvar dir = vector.sub(camera.position).normalize()\n\t\tvar distance = -camera.position.z / dir.z\n\t\tvar pos = camera.position.clone().add(dir.multiplyScalar(distance))\n\t\t// mesh.position.copy(pos)\n\t\tmesh.position.lerp(pos, 0.2)\n\t}\n\ttest.update()\n\t/*------------------------------\n    Update Shader Uniforms\n    ------------------------------*/\n\t// material.uniforms[ 'uTime' ].value = .00025 * ( Date.now() - start );\n\tmaterial.uniforms.uTime.value = clock.getElapsedTime()\n\t/*------------------------------\n  Render\n  ------------------------------*/\n\trenderer.render(scene, camera)\n\n\t/*------------------------------\n  Core\n  ------------------------------*/\n\twindow.requestAnimationFrame(animate)\n}\n\nanimate()\n","export default \"uniform float uTime;\\nvarying vec3 newPos;\\nvarying vec2 vUv;\\nvarying float noise;\\nuniform sampler2D tExplosion;\\n\\nfloat random( vec3 scale, float seed ){\\n  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;\\n}\\n\\nvoid main() {\\n\\n  // get a random offset\\n  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\\n  // lookup vertically in the texture, using noise and offset\\n  // to get the right RGB colour\\n//   vec2 tPos = vec2( 0, 1.3 * noise + r );\\n  vec4 color = texture2D( tExplosion, vUv );\\n//   color = vec4(0.949, 0.0, 0.0, 0.0);\\n\\n  gl_FragColor = vec4( color.rgb, 1.0 );\\n\\n}\";"],"names":["video","document","getElementById","canvas","context","getContext","mappedVal","mappedValY","trackButton","preloader","track","isVideo","model","runDetection","detect","then","predictions","slice","forEach","prediction","label","midval","bbox","midvalY","midval2","width","midvalY2","height","mapRange","renderPredictions","requestAnimationFrame","THREE","Vector2","addEventListener","gsap","to","opacity","delay","duration","handTrack","stopVideo","startVideo","status","style","display","load","flipHorizontal","maxNumBoxes","iouThreshold","scoreThreshold","lmodel","console","log","disabled","canvas3","querySelector","scene","Scene","renderer","WebGLRenderer","img","texture","dummyimg","createElement","onload","Texture","this","needsUpdate","geometry1","IcosahedronGeometry","material1","MeshBasicMaterial","map","newMesh","Mesh","add","src","TextureLoader","light","AmbientLight","geometry","material","ShaderMaterial","uniforms","tExplosion","type","value","uTime","uFreq","vertexShader","fragmentShader","mesh","sizes","window","innerWidth","innerHeight","camera","PerspectiveCamera","position","z","setSize","setPixelRatio","Math","min","devicePixelRatio","aspect","updateProjectionMatrix","fullscreenElement","exitFullscreen","requestFullscreen","test","constructor","x","y","m","radius","widthSeg","heightSeg","SphereBufferGeometry","testGeo","BoxGeometry","color","Vector3","vel","random","acc","mass","applyForce","force","f","update","clampScalar","set","a","b","c","d","event","clock","Clock","animate","elapsedTime","getElapsedTime","tracked","rotation","mover","attractor","amass","mmass","sub","setLength","attract","vector","unproject","dir","normalize","distance","pos","clone","multiplyScalar","lerp","render"],"sourceRoot":""}